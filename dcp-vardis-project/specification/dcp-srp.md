---

# The State-Reporting Protocol (SRP) {#chap-state-reporting-protocol}

This chapter describes the DCP state-reporting protocol (SRP).


## Purpose

The state-reporting protocol (SRP) provides frequent transmission of
safety-related information about a drone (such as its position, speed,
heading and any other safety-related data) to neighboured drones,
inside of beacons. In the other direction, it receives those safety
transmissions from neighboured drones and consolidates them into a
**neighbour table**, which can be used by applications to check, for
example, the risk of an imminent collision. The size of the
neighbourhood is determined by external factors such as the chosen
transmit power or properties of the propagation environment, and is
not under the control of this protocol. The neighbour table entries
are equipped with a soft-state mechanism. The safety-related
information has strictly single-hop scope.

The SRP operates on top of the beaconing protocol (see Section
[Beaconing Protocol](#chap-beaconing-protocol)) as a client
protocol. 


## Key Data Types and Definitions

### Data Types

- The transmissible data type `SRPSequenceNumberT` is a 32-bit unsigned
  integer. Sequence numbers are included in SRP payloads of type
  `ExtendedSafetyDataT`.

- The transmissible data type `SafetyDataT` refers to all the data that
  a drone wants to transmit to its neighbours, for example its current
  position, speed and direction, or some information about its
  short-term trajectory. The precise details of this data type are
  implemention-dependent and therefore the generation of values is
  left to applications, but `SafetyDataT` records have a fixed size
  (given by `ssizeof(SafetyDataT)`).

- The transmissible data type `ExtendedSafetyDataT` acts as a wrapper
  around the type `SafetyDataT`. It contains additional fields, and the
  SRP is actually concerned with the transmission of values of type
  `ExtendedSafetyDataT` and their storage as a whole in the neighbour
  table.  An `ExtendedSafetyDataT` record contains the following fields:
    - `sData` of type `SafetyDataT` is the actual safety data record
      wrapped into the present `ExtendedSafetyDataT` record.
    - `nodeId` of type `NodeIdentifierT` contains the node identifier
      of the node that generated the `ExtendedSafetyDataT` record. 
    - `tStamp` of type `TimeStampT` (see Section [Data
      Types](#chap-datatypes)) is generated by the SRP when a
      `SafetyDataT` record is handed down by applications for future
      transmission.
    - `seqno` of type `SRPSequenceNumberT` is a sequence number
      associated with the present `ExtendedSafetyDataT` record. Two
      successive `ExtendedSafetyDataT` records generated in response to
      two `SafetyDataT` records received from the application must have
      distinct sequence numbers.
  
- The non-transmissible data type `NeighbourTableEntry` record has the
  following fields:
    - `nodeId` of type `NodeIdentifierT`
    - `extSD` of type `ExtendedSafetyDataT` is the last value of type
      `ExtendedSafetyDataT` received from the drone with identifier
      `nodeId`.
	- `receptionTime` of type `TimestampT` contains the local timestamp
	  of the time the last value in `extSD` has been received, as
	  generated by the receiving SRP entity upon successfully processing a
	  received `BP-ReceivePayload.indication` primitive. Assuming
	  sufficiently well-synchronized local clocks among neighboured
	  nodes, the difference between this timestamp and the timestamp
	  contained in `extSD.tStamp` gives application an indication of
	  the delay introduced by the underlying BP and UWB.
    - Implementations can choose to add additional fields,
      e.g. estimates of packet loss rates towards individual
      neighbours (as estimated from the `seqno` field of an
      `ExtendedSafetyDataT` record).

### The Neighbour Table

The non-transmissible `NeighbourTable` data type is a collection of a
number of `NeighbourTableEntry` records, together with some
pre-defined operations on this collection. These include:

- `ntLookup(nodeId)`: the parameter `nodeId` is of type
  `NodeIdentifierT` and refers to the identifier of the node for which 
  a full `NeighbourTableEntry` can be found in the table. This
  operation can end unsuccessful if the table does not contain
  an entry for which its `nodeId` field equals the parameter, in which
  case a `NULL` value is returned. Alternatively, if such an entry
  exists, it returns this (unique) entry.
- `ntListAllNodeIds()`: returns a list of all `nodeId` fields for all
  `NeighbourTableEntry` records currently in the neighbour table, in
  no guaranteed order.

There is a single variable `neighbourTable` of type
`NeighbourTable`. The neighbour table only contains records for
neighboured nodes, not for the hosting node itself.

It is implementation-dependent how the neighbour table operations are
used by applications.

An implementation might provide additional, more specific functions
for querying the contents of the `NeighbourTable`, e.g. listing
entries in order of increasing distance or entries of a certain
minimum age. Applications can use these functions for example to
assess the risk of a collision in a given time window, or to assess
the amount of uncertainty in the position data of a neighbour from the
available timestamps.

### The Sequence Number

The SRP entity maintains a global variable called
`currentSequenceNumber` of type `SRPSequenceNumberT`, initialized to
zero during initialization, and incremented after each time a new
`ExtendedSafetyDataT` record is submitted to the beaconing protocol.


## Interface

SRP offers its services to the applications through the service
interface described in the following.

Whenever an application submits a service request primitive, SRP must
check whether it is currently registered as a client protocol with
BP. If not, then SRP must reject the service request primitive,
i.e. send back a confirm primitive with status code
`SRP-STATUS-INACTIVE' to the application.

### Service SRP-UpdateSafetyData

The purpose of this service is to allow an application to submit a new
`SafetyDataT` record for transmission.

The service user invokes this service by using the
`SRP-UpdateSafetyData.request` primitive, which carries the following
parameters:

- `sData` of type `SafetyDataT`

The SRP entity responds with a `SRP-UpdateSafetyData.confirm`
primitive, generated immediately upon processing the
`SRP-UpdateSafetyData.request` primitive.


To process the `SRP-UpdateSafetyData.request` primitive the SRP
instance performs at least the following actions:

~~~
1.     Let extsd : ExtendedSafetyDataT with
           extsd.sData   =  sData
		        .nodeId  =  ownNodeIdentifier
				.tStamp  =  current system time
				.seqno   =  currentSequenceNumber
2.     increment currentSequenceNumber modulo (MAXVAL(SRPSequenceNumberT)+1)
3.     Prepare BP-TransmitPayload.request primitive req with
          req.protId  = BP_PROTID_SRP
		     .length  = ssizeof(ExtendedSafetyDataT)
			 .payload = extsd
4.     Submit req to BP.
5.     stop processing, return SRP-STATUS-OK
~~~

Here, `ownNodeIdentifier` (of type `NodeIdentifierT`) is the node
identifier of the current node, see Section [SRP
initialization](#srp-initialization).


### Neighbour Table Access

The way applications access the neighbour table is considered as
implementation-dependent and not specified in this document.


### Non-configurable Parameters

During initialization, the SRP entity obtains the value
`ownNodeIdentifier` of type `NodeIdentifierT`, which contains the node
identifier of the current node, see Section [SRP
initialization](#srp-initialization).



### Configurable Parameters {#srp-configurable-parameters}

- `SRPPAR_NEIGHBOUR_TABLE_TIMEOUT` in milliseconds: if a node doesn't
  receive a new `ExtendedSafetyDataT` record from a particular
  neighbour for this many milliseconds, then the neighbour table entry
  will be dropped from the neighbour table. Default value: 3,000
  (corresponding to 3 seconds). There is no guarantee on how
  accurately this timing will be observed by the SRP entity.


## Packet Format

The payloads transmitted and received by SRP are all of type
`ExtendedSafetyDataT`.


## Initialization, Runtime and Shutdown

The SRP will have to perform certain actions besides processing
packets or responding to service requests from the application.


### Initialization {#srp-initialization}

During the initialization, the SRP will need to register itself as a
client protocol with the underlying BP before it can process any
`SRP-UpdateSafetyData.request` primitives. To achieve this
registration, the SRP prepares a `BP-RegisterProtocol.request` service
primitive (see [Service
BP-RegisterProtocol](#bp-interface-service-bp-register-protocol)) with
the following parameters:

- `protId` is set to `BP_PROTID_SRP` (see Section [BP Data
  types](#subsubsec-beaconing-protocol-data-types)).
- `name` is set to "SRP -- State Reporting Protocol Vx.y" where
  'x' and 'y' refer to the present version of SRP. Currently, the
  version number is "V1.1".
- `maxPayloadSize` is set to
  `ssizeof(ExtendedSafetyDataT)`. Implementations may opt to add an
  additional safety margin.
- `queueingMode` is set to `BP_QMODE_REPEAT`, meaning that the
  BP will always transmit the last `ExtendedSafetyDataT` record that the
  SRP has handed over.

Optionally, before registering with the BP, the SRP entity can choose
to first submit a `BP-DeregisterProtocol.request` primitive with
`protId` field set to `BP_PROTID_SRP`, to cover the case that a
previously running SRP instance has crashed and the current instance
is re-started, see Section [Recommended behaviour of client
protocols](#bp-recommended-behaviour-client-protocols).

The variable `neighbourTable` of type `NeighbourTable` is  initialized
as being empty.

The variable `currentSequenceNumber` of type `SRPSequenceNumberT` is
initialized to zero.

Furthermore, the SRP determines the node identifier of the current node
from the `BP-RegisterProtocol.confirm` primitive received in response
to the own `BP-RegisterProtocol.request` primitive.

Before the initialization has successfully concluded, the SRP entity
will not allow any access by applications to the neighbour table, nor
will it respond to any `SRP-UpdateSafetyData.request` primitives.


### Runtime

The SRP entity traverses the neighbour table `neighbourTable` at a
frequency chosen such that during any time interval of length
`SRPPAR_NEIGHBOUR_TABLE_TIMEOUT` (see [Configurable
Parameters](#srp-configurable-parameters)) at least five traversals
are carried out. During each traversal the SRP entity first obtains
the current system time and then checks for each entry `ent` of type
`ExtendedSafetyDataT` contained in `neighbourTable` whether the
difference between the current system time and the
(receiver-generated) timestamp `ent.receptionTime` exceeds the value
of the `SRPPAR_NEIGHBOUR_TABLE_TIMEOUT` parameter. If so, the
neighbour table entry is dropped from the table.


### Shutdown

During the shutdown, the SRP will de-register itself from the
BP, by issueing the service primitive `BP-DeregisterProtocol.request`
with the `protId` parameter set to `BP_PROTID_SRP`.



## Receive Path

The receive path is activated when the underlying BP signals the
reception of an SRP payload with the `BP-ReceivePayload.indication`
primitive (see [Service
BP-ReceivePayload](#bp-service-bp-receive-payload)). In this case,
referring to the received primitive as `payloadIndication`, the SRP
performs at least the following actions:

~~~
1.     If (    (payloadIndication.protId != BP_PROTID_SRP)
            || (payloadIndication.length != ssizeof(ExtendedSafetyDataT)) then
          stop processing.
2.     Let ext : ExtendedSafetyDataT = payloadIndication.payload
3.     If (ext.nodeId == own node identifier) then
          stop processing.
4.     Let ent : NeighbourTableEntry with
	       ent.nodeId         =  ext.nodeId
			  .extSD          =  ext
			  .receptionTime  =  current system time
          add ent to neighbourTable or replace existing entry for ext.nodeId
		  stop processing.
~~~

Implementations may choose to extend the data type
`NeighbourTableEntry` by further fields and add appropriate processing
here. For example, the sequence numbers contained in values of type
`ExtendedSafetyDataT` can be used to estimate packet loss rate between
the neighbour and the the current node. Implementations may also
choose to filter out newly received records based on sequence numbers,
but this is not recommended due to problems with re-starts and
re-initialization of nodes.
