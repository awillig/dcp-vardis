---

# The VarDis (Variable Dissemination) Protocol {#chap-vardis}

This section describes the Variable Dissemination (VarDis) protocol.

## Purpose

On the highest level, VarDis is concerned with the maintenance of a
**real-time database**, which is simply defined to be a collection of
**variables** and is not in any way related to contemporary relational
or non-relational database management systems. The variable concept of
VarDis supports the four key operations of create, read, update and
delete (CRUD). Each variable is created by exactly one node, and that
same node is the only node that is allowed to modify the variable --
we occasionally refer to this node as the **producer** of that
variable. All other nodes are only allowed to read the current
variable value, we refer to them as the **consumers**. The role of the
producer does not change during the lifetime of the variable, and the
producer is the only node allowed to update its value or delete the
variable.

A key responsibility of VarDis is to disseminate updates to the
variable as quickly and reliably as possible in the network and to
keep the real-time database in a consistent state across all
nodes. The key vehicle for that, and the feature that distinguishes
VarDis from other approaches, is that dissemination of variable
updates relies on piggybacking them on frequently transmitted beacons
(with beacon transmission provided by the underlying BP, for which
VarDis is a client protocol) instead of flooding updates separately.

The real-time database itself is dynamic in the sense that variables
can be created or removed at runtime.

The real-time database is not tied to any notion of persistency, and
there is no guarantee that any node will be able to track all updates
made to a variable. Furthermore, the moniker "real-time" should not be
interpreted strictly, as no guarantees on dissemination speed or
reliability will and can be given. It merely captures an aspiration to
be both fast and reliable.


## Key Data Types and Definitions

### Variables

We start by defining some data types related to variables.

- The transmissible data type `VarIdT` (short for variable identifier)
  is an unsigned integer. Each variable needs to have a unique
  identifier, but uniqueness must be ensured by developers, it is not
  strictly enforced by VarDis.

- The transmissible data type `VarLenT` (short for variable length) is
  an unsigned integer describing the length of a variables value in
  memory as a number of bytes. VarDis treats a variable as just a
  block of bytes of given length. Note that the length of (the values
  of) a variable is not fixed over time, at different times a variable
  can have values of different lengths. The variable length must not
  exceed a configurable maximum variable length (parameter
  `VARDISPAR_MAX_VALUE_LENGTH`, see [Configurable
  Parameters](#vardis-configurable-parameters)).

- The transmissible data type `VarRepCntT` is an unsigned integer,
  which specifies for a variable in how many distinct beacons a node
  should repeat information pertaining to that variable (create or
  delete operations, updates).

- The transmissible type `VarSpecT` (short for variable specification)
  represents a record collecting all the metadata or attributes
  describing a variable. All these attributes remain fixed throughout
  its lifetime. Furthermore, VarDis does not keep track of the type of
  a variable, it just treats the value of a variable as a block of
  bytes without further structure. Any interpretation of a variable
  (including its association with a datatype) is handled by the
  applications. A `VarSpecT` has the following fields:
	- `varId` of type `VarIdT`:  unique numerical variable identifier.
	- `prodId` of type `NodeIdentifierT`: the node identifier of
	  the variable producer.
	- `repCnt` of type `VarRepCntT`: its repetition count.
	- `descr` of type `StringT`: a human-readable description of the
	  variable.

- The transmissible data type `VarSeqnoT` is an unsigned integer using
  an integral number `n` of bytes. Sequence numbers are used in a
  circular fashion. The sequence number space ranges from 0 to
  `SEQNO-MODULUS` minus one, where `SEQNO-MODULUS` equals $2^n$.  Each
  producer of a variable maintains a separate local sequence number
  for that variable. This sequence number is incremented upon every
  new update operation and included in the disseminated
  update. Sequence numbers are used by nodes to check whether they
  have the most recent value of a variable.
  
- The transmissible data type `VarUpdT` (short for variable update) is
  generated by the producer of a variable when its application writes
  to it, and the update is then disseminated by VarDis to all nodes in
  the network. A `VarUpdT` record includes the following fields:
  - `varId` of type `VarIdT`: identifier of the variable
  - `seqno` of type `VarSeqnoT`: a sequence number as managed by the
    producer, such that successive updates have distinct sequence
    numbers.
  - `length` of type `VarLenT`: gives the length of the variables value
    as a number of bytes.
  - `value`: The value of the variable as a block of bytes. The length
    of this block of bytes is the same as the length given in the
    `length` field for this variable.

- The transmissible data type `VarCreateT` (short for variable
  creation) collects all the information the producer of a variable
  disseminates upon creation of a variable. It contains the following
  fields:
  - `spec` of type `VarSpecT` contains all the metadata describing the
    variable.
  - `upd` of type `VarUpdT` contains the initial value of the variable.

- The transmissible data type `VarSummT` (short for variable summary)
  is used to let nodes include variable summaries in their beacons to
  let neighbours know what is the most recent update to a variable
  they have received (either from applications if it is the producer,
  or from other nodes if it is a consumer). A `VarSummT` includes the
  following fields:
  - `varId` of type `VarIdT`: identifier for a variable that the
    sending node has in its real-time database (i.e. an existing
    variable).
  - `seqno` of type `VarSeqnoT`: the seqno of the most recent variable
    update (of type `VarUpdT`) that the sender has received.


### Information Elements {#vardis-definitions-information-elements}


The VarDis payload of a beacon packet is made up of one or more
**information elements** (IE), which hence are transmissible data
types. Each information element consists of an `IEHeaderT`, followed by
a list of records of the same type, which depends on the type of
information element -- we refer to this list as the `IEList`. Each
such record represents information about a variable with given
`VarIdT`. Note that the individual records of an information element
can have different lengths (e.g.\ `VarUpdT` records for different
variables).

The `IEHeaderT` is a transmissible data type with the following two
fields:
- The field `ieType` (for information-element type) specifies the
  particular type of information element being considered. The allowed
  values are:
    - `ieType = 1` for `IETYPE-SUMMARIES`
    - `ieType = 2` for `IETYPE-UPDATES`
    - `ieType = 3` for `IETYPE-REQUEST-VARUPDATES`
    - `ieType = 4` for `IETYPE-REQUEST-VARCREATES`
    - `ieType = 5` for `IETYPE-CREATE-VARIABLES`
    - `ieType = 6` for `IETYPE-DELETE-VARIABLES`

- The field `ieNumRecords` specifies the number of records in this
  information element.

The encoding of the `ieType` and `ieNumRecords` fields is
implementation-dependent.

A VarDis payload transmitted in a beacon can contain at most one of
each of the following types of information elements, as long as their
combined size fits within the allowed payload size (cf. parameter
`VARDISPAR_MAX_PAYLOAD_SIZE`, see Section [Configurable
Parameters](#vardis-configurable-parameters)). 

In the following we describe the key information elements used by
VarDis.


#### `IETYPE-SUMMARIES` (`ieType` = 1)

The `IEList` is a list of `VarSummT` records, where each `VarSummT`
includes a variable identifier (of type `VarIdT`) and a sequence number
(of type `VarSeq`), representing the latest sequence number received
for that variable. A neighbour receiving this information element can
compare the received summaries with the contents of its own real-time
database and check whether it misses any variables, only has them in
outdated versions, or has itself newer versions than the sending
neighbour.


#### `IETYPE-UPDATES` (`ieType` = 2)

The `IEList` is a list of `VarUpdT` records. The transmitter includes
the latest variable values and sequence numbers it has stored in its
real-time database (but not necessarily for all the variables in the
database). The intention is that the receiver will itself repeat that
update as many times in distinct future beacons as indicated by the
`repCnt` field of the corresponding variable specification (type
`VarSpecT`), to further propagate the update in the network. This is
conditional on this update being truly new to the receiver,
i.e. having a sequence number strictly larger than the sequence number
it previously had stored for the same variable.


#### `IETYPE-REQUEST-VARUPDATES` (`ieType` = 3)

The `IEList` consists of a list of pairs of type (`VarIdT`,
`VarSeqnoT`), which can be represented by elements of type
`VarSummT`. The intention is that the sending node requests any / all
of its neighbours to send `VarUpdT` records for the requested
`VarIdT` some time in the future, in as many distinct future beacons
as given by the `repCnt` field of the corresponding variable
specification (`VarSpecT`), provided that the neighbours have strictly
more recent versions of the requested variables than indicated by the
included sequence number.


#### `IETYPE-REQUEST-VARCREATES` (`ieType` = 4)

The `IEList` consists of a list of `VarIdT` values. The intention is
that the sending node requests any / all of its neighbours to send
`VarCreateT` records for each of the requested variables (each of which
combines a `VarSpecT` record and a `VarUpdT` record), which they will
embed into `IETYPE-CREATE-VARIABLES` information elements some time in
the future, in as many distinct beacons as indicated by the `repCnt`
parameter of the corresponding variable specifications (of type
`VarSpecT`).


#### `IETYPE-CREATE-VARIABLES` (`ieType` = 5)

The `IEList` consists of a list of `VarCreateT` records, which
themselves are pairs of variable specifications (`VarSpecT`) and
initial values and sequence numbers (`VarUpdT`). The intention is that
the sending node notifies the neighbour that new variables (together
with their initial values) have been added to the real-time database,
and for the neighbour to further repeat the `VarCreateT` records in as
many distinct future beacons as indicated in the `repCnt` field of
the variable specification (`VarSpecT`).


#### `IETYPE-DELETE-VARIABLES` (`ieType` = 6)

The `IEList` is a list of `VarIdT` values. The intention is that the
sending node notifies the neighbour that the given variables are to be
deleted from the real-time database, and for the neighbour to further
repeat the `VarIdT` values in as many distinct future beacons as
indicated in the `repCnt` field of the variable specification
(`VarSpecT`).


#### Global vs. Local Dissemination

The three information elements `IETYPE-SUMMARIES`,
`IETYPE-REQUEST-VARUPDATE` and `IETYPE-REQUEST-VARSPEC` have
single-hop scope, i.e. the sender wishes to reach only its immediate
neighbours. These information elements are not included by the
receivers in their own beacons for further dissemination.

In contrast, the `IETYPE-UPDATES`, `IETYPE-CREATE-VARIABLES` and
`IETYPE-DELETE-VARIABLES` information elements have global scope. In
particular, when a receiver recognizes that the data contained in any
of these information elements is either truly new (i.e. the receiver
has not received it before) or truly updated (i.e. the receiver only
has a strictly older value of a variable), then it will in turn
include the received data (of type `VarUpdT`, `VarCreateT` or `VarIdT`)
in as many distinct future beacons as indicated by the `repCnt`
parameter of the corresponding variable specification (`VarSpecT`), to
help with further propagation in the network.


### Real-Time Database

The real-time database is a collection of variables, with `VarIdT`'s
used as a key. For each `VarIdT` there exists a database entry of
the non-transmissible type `DBEntry`, containing the following
elements:

- `spec` of type `VarSpecT`: contains the variable specification
  for the variable, as received in an `IETYPE-CREATE-VARIABLES`
  information element. The `VarSpecT` includes the identifier of the
  variable (of type `VarIdT`).
- `length` of type `VarLenT`: the length in bytes of the current value
  of the variable.
- `value` of type byte array: the current value of the variable.
- `seqno` of type `VarSeqnoT`: the sequence number corresponding to the
  current value of the variable. The `length`, `value` and `seqno`
  fields have been received in the last valid `IETYPE-UPDATES`
  (carrying a `VarUpdT` for this variable) or `IETYPE-VARCREATE`
  (carrying a `VarCreateT` record) elements received for that variable.
- `tStamp` of type `TimeStamp`: gives the last time (in local system
  time) that a valid `VarUpdT` or `VarCreateT`  for this variable has
  been received and processed.
- A counter `countUpdate` of type `VarRepCntT`, indicating how many
  more times a recently received update (`VarUpdT`) for this variable
  is to be included into distinct beacons.
- A counter `countCreate` of type `VarRepCntT`, indicating how many
  more times a recently received `VarCreateT` for this variable is to
  be included into distinct beacons.
- A counter `countDelete` of type `VarRepCntT`, indicating how many
  more times a recently received instruction to delete the variable
  (it's `VarIdT`) is to be included into distinct beacons.
- A flag `toBeDeleted` of type `Bool` to indicate whether the variable is
  marked for deletion (`true`) or not (`false`). A variable  deletion
  is not immediately carried out in the moment an
  `IETYPE-DELETE-VARIABLES` element is processed, but only after the
  deletion instruction has been repeated in beacons sufficiently
  often. This flag is to be initialized with `false`.

The real-time database supports three main operations:

- `RTDB.lookup()`, which takes as parameter a value of type `VarIdT`
  and either returns the unique database entry `ent` (of type
  `DBEntry`) for which `ent.spec.varId` equals the given `VarIdT`
  value, or an indication that no such entry exists.
- `RTDB.remove()`, which takes as parameter a value of type
  `VarIdT`. If the database contains an entry `ent` for which
  `ent.spec.varId` equals the given `VarIdT` value, then the entry
  is removed from the database, otherwise nothing happens.
- `RTDB.update()`, which takes as parameter a value of type
  `DBEntry`, referred to as `newent`. If the database contains no
  entry `ent` for which `ent.spec.varId == newent.spec.varId`, then
  `newent` is added to the database, otherwise the old entry `ent` is
  replaced by `newent`.



### Queues {#vardis-definitions-queues}

A beacon can contain only one instance of each type of information
elements. To manipulate and specify the contents of the information
elements in future beacons, for each `ieType` VarDis maintains a
number of variables of type `Queue<VarIdT>` (see Section [Queues and
Lists](#sec-queues-lists)). In addition to the standard operations on
queues, in VarDis we make use of the following three additional
operations:

- `qDropNonexistingDeleted()` drops all `VarIdT` values from the given
  queue for which either `RTDB.lookup()` indicates that the
  corresponding variable does not exist in the real-time database or
  the database entry for the variable (of type `DBEntry`) has the
  `toBeDeleted` flag set to `true`.
- `qDropNonexisting()` drops all `VarIdT` values from the given queue
  for which `RTDB.lookup()` indicates that the corresponding variable
  does not exist in the real-time database.
- `qDropDeleted()` drops all `VarIdT` values from the given queue
  for which `RTDB.lookup()` indicates that the corresponding variable
  exist in the real-time database but has its `toBeDeleted` flag set
  to `true`.

A VarDis entity maintains the following queues at runtime, all of type
`Queue<VarIdT>`:

- `createQ`: contains `VarIdT` values for all the variables for
  which further repetitions of the `VarCreateT` information records
  have to be included in future beacons (inside of
  `IETYPE-CREATE-VARIABLES` information elements).
- `deleteQ`: contains `VarIdT` values for all the variables for
  which further repetitions of the `VarIdT` value for deletion have to
  be included into  future beacons (inside of
  `IETYPE-DELETE-VARIABLES` information elements).
- `updateQ`: contains `VarIdT` values for all the variables for
  which further repetitions of their most recent value and sequence
  number (`VarUpdT` records) have to be included in future beacons
  (inside of `IETYPE-UPDATES` information elements).
- `summaryQ`: like `updateQ`, but with summaries (type `VarSummT`)
  instead of updates.
- `reqUpdQ`: contains `VarIdT` values for all the variables for
  which a `VarSummT` (inside an `IETYPE-REQUEST-VARUPDATE` information
  element) is to be transmitted in a future beacon, to request a
  `VarUpdT` from neighboured nodes.
- `reqCreateQ`: like `reqUpdQ`, but for `VarIdT` values used to
  request `VarCreateT` records from neighboured nodes.



## Interface

An application is mainly concerned with maintaining and accessing the
real-time database (RTDB), which is a collection of variables. The
interaction between an application and the real-time database happens
through the following pre-defined services. For each service we
specify a request primitive, which the application uses to request a
service, and a confirm primitive, through which the local VarDis
entity provides its response to the service request to the local
application. We furthermore sketch how the VarDis entity processes a
service request.

Whenever an application submits a service request primitive, VarDis
must check whether it is currently registered as a client protocol
with BP. If not, then VarDis must reject the service request
primitive, i.e. send back a confirm primitive with status code
`VARDIS-STATUS-INACTIVE' to the application.



### Describing Database Contents {#vardis-service-database-contents}

#### Service `RTDB-DescribeDatabase` {#vardis-service-database-contents-describe-db}

The application issues a `RTDB-DescribeDatabase.request`
primitive. This primitive carries no further parameters. The intention
is that the application is being provided with a list of `VarSpecT`
records for all variables currently in the RTDB.

The VarDis entity responds with a `RTDB-DescribeDatabase.confirm`
primitive. This primitive carries as data a list of the `VarSpecT`
records of all variables currently in the real-time database,
including those that have their `toBeDeleted` flag set in their
respective `DBEntry` records. Implementations can choose to add
additional fields from the `DBEntry` record of a variable, for example
its timestamp field `tStamp`.


#### Service `RTDB-DescribeVariable`

The application issues a `RTDB-DescribeVariable.request` primitive,
which carries a value of type `VarIdT` as a parameter. The intention is
that the application is being provided with the full entry of the RTDB
for that variable (of type `DBEntry`), or with a signal that the
variable does not exist.

If the requested variable does not exist in the real-time database,
then the VarDis entity responds with a
`RTDB-DescribeVariable.confirm` primitive carrying the status code
`VARDIS-STATUS-VARIABLE-DOES-NOT-EXIST`. If the variable does exist,
the VarDis entity responds with the same primitive, but now carrying
the status code `VARDIS-STATUS-OK` and the `DBEntry` record for this
variable as parameters.


### CRUD Operations on Variables

#### Service `RTDB-Create`

An application wishes to create a variable and provides an initial
value. If successful, then the current node automatically becomes the
producer for this variable.

The application issues a `RTDB-Create.request` primitive, which
carries the following parameters:

- `spec` of type `VarSpecT`: the variable specification of the new
  variable. Its identifier (`spec.varId`) must be unique, i.e. there
  should be no active variable with the same `VarIdT` value
  currently in the real-time database.
- `length` of type `VarLenT`: The length of the initial value to be
  written.
- `value` of type byte array: The actual initial value, as a block of
  bytes. This has to be exactly as many bytes as given in the `length`
  parameter.

The `RTDB-Create.confirm` primitive is returned after the VarDis
entity has finished processing the request. As a parameter it only
includes a status code.

To process the request, the VarDis entity performs the following
steps:

~~~
1.     If (RTDB.lookup(spec.varId) == true) then
          stop processing, return status code VARDIS_STATUS_VARIABLE_EXISTS
2.     If (spec.descr.length > (VARDISPAR_MAX_DESCRIPTION_LENGTH-1)) then
          stop processing, return status code VARDIS_STATUS_VARIABLE_DESCRIPTION_TOO_LONG
3.     If (length > VARDISPAR_MAX_VALUE_LENGTH) then
          stop processing, return status code VARDIS_STATUS_VALUE_TOO_LONG
4.     If (length == 0) then
          stop processing, return status code VARDIS_STATUS_EMPTY_VALUE
5.     If (    (spec.repCnt <= 0)
            || (spec.repCnt > VARDISPAR_MAX_REPETITIONS)) then
		  stop processing, return status code VARDIS_STATUS_ILLEGAL_REPCOUNT

6.     Let newent : DBEntry with
           newent.spec         =  spec
		   newent.length       =  length
		   newent.value        =  value
		   newent.seqno        =  0
		   newent.tStamp       =  current system time
		   newent.countUpdate  =  0
		   newent.countCreate  =  spec.repCnt
		   newent.countDelete  =  0
		   newent.toBeDeleted  =  False

7.     createQ.qRemove (spec.varId)
8.     deleteQ.qRemove (spec.varId)
9.     updateQ.qRemove (spec.varId)
10.	   summaryQ.qRemove (spec.varId)
11.	   reqUpdQ.qRemove (spec.varId)
12.	   reqCreateQ.qRemove (spec.varId)

13.    RTDB.update(newent)
14.    createQ.qAppend (spec.varId)
15.    summaryQ.qAppend (spec.varId)
16.    return status code VARDIS_STATUS_OK
~~~


A successful completion of this service request only means that the
variable has now been added to the real-time database **on the
producer node**. It may take an indefinite amount of time before the
new variable is known to any other node in the network.

The checking of uniqueness of a variable is quite limited. We can
reliably discover the case where a variable is to be created twice on
the same producer node, but there are other pathological cases we
cannot immediately discover, and the protocol makes no attempt to
prevent, resolve or report such a situation. One example of such a
situation is when two nodes at far away ends of a large multi-hop
network want to create the same variable at more or less the same
time. None of the two nodes will be aware of the other one's efforts,
and quite likely it will be some intermediate nodes noticing a Create
request for an already existing variable (and coming from a different
producer node).



#### Service `RTDB-Delete` {#vardis-service-database-contents-delete-var}

An application wishes to delete a variable. To be effective, this must
be issued on the producer node, other nodes cannot delete a variable.

To request deletion of a variable, an application uses the
`RTDB-Delete.request` primitive, which carries as a parameter the
`VarIdT` value of the variable to be deleted, referred to as `varId`
below.

The `RTDB-Delete.confirm` primitive is returned after the VarDis
entity has finished processing the request. As a parameter it only
carries a status code.

To process the request, the VarDis entity performs the following
steps:

~~~
1.     If (RTDB.lookup(varId) == false) then
           stop processing, return status code VARDIS_STATUS_VARIABLE_DOES_NOT_EXIST
2.     Let ent = RTDB.lookup(varId)
3.     If (ent.spec.prodId =/= own node identifier) then
           stop processing, return status code VARDIS_STATUS_NOT_PRODUCER
4.     If (ent.toBeDeleted == true) then
           stop processing, return status code VARDIS_STATUS_VARIABLE_BEING_DELETED
5.     deleteQ.qAppend(varId)
6.     createQ.qRemove(varId)
7.     summaryQ.qRemove(varId)
8.     updateQ.qRemove(varId)
9.     reqUpdQ.qRemove(varId)
10.    reqCreateQ.qRemove(varId)
11.    ent.toBeDeleted   =  True
12.    ent.countDelete   =  ent.spec.repCnt
13.    ent.countCreate   =  0
14.    ent.countUpdate   =  0
15     RTDB.update(ent)
16.    return status code VARDIS_STATUS_OK
~~~

A successful completion of this primitive only means that now the
deletion process for the chosen variable has started **on the producer
node**. It takes an unspecified amount of time before the variable is
actually deleted from the real-time databases of all nodes (including
the producer node). To check for deletion on the producer node, an
application can issue the `RTDB-DescribeDatabase.request` service
primitive at a later point in time (see [Service
`RTDB-DescribeDatabase](#vardis-service-database-contents-describe-db)).


#### Service `RTDB-Update`

An application on the producer node wishes to write a new value to
the variable.

To achieve that, the application issues the `RTDB-Update.request`
primitive, which carries three parameters:

- `varId` of type `VarIdT`: the identifier of the variable to be
  updated 
- `length` of type `VarLenT`: the length of the new variable value
- `value` of type byte array: The actual new variable value, as a
  block of bytes. This has to be exactly as many bytes as given in
  the `length` parameter.

The `RTDB-Update.confirm` primitive is returned after the VarDis
entity has finished processing the request. As a parameter it only
carries a status code.

To process the request, the VarDis entity performs the following
steps:

~~~
1.     If (RTDB.lookup(varId) == false) then
           stop processing, return status code VARDIS_STATUS_VARIABLE_DOES_NOT_EXIST
2.     Let ent = RTDB.lookup(varId)
3.     If (ent.spec.prodId =/= own node identifier) then
           stop processing, return status code VARDIS_STATUS_NOT_PRODUCER
4.     If (ent.toBeDeleted == True) then
           stop processing, return status code VARDIS_STATUS_VARIABLE_BEING_DELETED
5.     If (length > VARDISPAR_MAX_VALUE_LENGTH) then
          stop processing, return status code VARDIS_STATUS_VALUE_TOO_LONG
6.     If (length == 0) then
          stop processing, return status code VARDIS_STATUS_EMPTY_VALUE
7.     Increment ent.seqno modulo SEQNO-MODULUS
8.     Set ent.length       = length
           ent.value        = value
		   ent.countUpdate  = ent.spec.repCnt
		   ent.tStamp       = current system time
9.     RTDB.update(ent)
10.    if (not updateQ.contains(varId))
        updateQ.qAppend(varId)
11.    return status code VARDIS_STATUS_OK
~~~


A successful completion of this primitive only means that the variable
has been updated **on the producer node**. It may take an indefinite
amount of time before it has been updated on any other node in the
network. Furthermore, there is no guarantee of order: if the producer
node updates a variable at time t~1~ with value v~1~ and a short time
later at time t~2~ it updates it with value v~2~, a given consumer
node may receive both updates in the same order and apply both updates
to its RTDB, or it receives the second update before the first one, in
which case it will ignore the first update completely (as from the
sequence numbers it is recognized as outdated after the second update
has been processed).


#### Service `RTDB-Read`

An application wishes to inquire the current value of a variable
stored in its local real-time database.

The application issues the `RTDB-Read.request` primitive, which
carries the `VarIdT` value of the variable as its only parameter.

The `RTDB-Read.confirm` primitive is returned after the VarDis entity
has finished processing the request. As a parameter it carries a
status code and, if the status code is `VARDIS_STATUS_OK`, also the
value of the variable (length field, data bytes) and the time stamp of
the last update of the variable.

To process the request, the VarDis entity performs the following
steps:

~~~
1.     If (RTDB.lookup(varId) == false) then
           stop processing, return status code VARDIS_STATUS_VARIABLE_DOES_NOT_EXIST
2.     Let ent = RTDB.lookup(varId)
3.     If (ent.toBeDeleted == True) then
           stop processing, return status code VARDIS_STATUS_VARIABLE_BEING_DELETED
4.     return status code VARDIS_STATUS_OK, ent.length, ent.value, ent.tStamp
~~~



### Configurable Parameters {#vardis-configurable-parameters}

The configurable parameters of VarDis can be set by applications or
station management entities through a suitably defined management
interface. Parameter changes are assumed to take effect immediately
and will apply to all subsequently generated beacons and service
invocations.

Here we only specify mandatory parameters that any VarDis
implementation needs to support. These are:

- `VARDISPAR_MAX_VALUE_LENGTH` is the maximum allowable length of a
  variable value. Default value is 32. The value must be larger than
  zero and must not exceed the minimum of the following values:
    - the maximum value representable in the `VarLenT` data type.
    - `VARDISPAR_MAX_PAYLOAD_SIZE` - `sizeof(IEHeaderT)`
  
- `VARDISPAR_MAX_DESCRIPTION_LENGTH` is the maximum length of a
  textual variable description (of type `StringT`) contained in a
  value of type `VarSpecT`. Default value is 32. The value must be
  larger than zero and must not exceed the value 
  `VARDISPAR_MAX_PAYLOAD_SIZE` - (`sizeof(IEHeaderT) +  sizeof(VarSpecT) + sizeof(VarUpdT) + VARDISPAR_MAX_VALUE_LENGTH`),
  where `sizeof(VarSpecT)` does not include the `descr` field and
  `sizeof(varUpdT)` does not include the `value` field.

  `VARDISPAR_MAX_REPETITIONS` gives the maximally allowed number of
  repetitions for a variable update, variable creation or variable
  deletion that a node may include into its outgoing beacons. A hard
  upper bound for this parameter is 15. The value must be at least
  one.

  `VARDISPAR_MAX_PAYLOAD_SIZE` is the maximum allowable length of a
  payload generated by VarDis and handed over to the underlying BP for
  transmission. The value must be larger than zero, and must not
  exceed the value
  `BPPAR_MAXIMUM_PACKET_SIZE-(sizeof(BPHeaderT)+sizeof(BPPayloadHeaderT))`,
  see Sections [BP Configurable
  Parameters](#bp-interface-configurable-parameters) and [BP Data
  Types](#subsubsec-beaconing-protocol-data-types).

  `VARDISPAR_MAX_SUMMARIES` is the maximum number of variable
  summaries (of type `VarSummT`) to be included in a payload in an
  `IETYPE-SUMMARIES` information element. It is a non-negative
  integer, which must not exceed `(VARDISPAR_MAX_PAYLOAD_SIZE-sizeof(IEHeaderT))/sizeof(VarSummT)`.
  If this value is zero, then no `IETYPE_SUMMARIES`
  information element is being created.

- `VARDISPAR_BUFFER_CHECK_PERIOD` specifies the period of time between
  checks of the number of payloads in the BP buffer for VarDis (see
  Section [Runtime](#vardis-runtime)). This value must be larger than
  zero.



## Payload Format and Payload Construction Process {#vardis-payload-format-construction}

We discuss how a node (the "current node") composes the VarDis payload
to be handed down for transmission to the underlying BP. The payload
is composed by appending information elements until either no further
elements are to be added, or the maximum allowed payload size
(parameter `VARDISPAR_MAX_PAYLOAD_SIZE`, see Section [Configuruable
Parameters](#vardis-configurable-parameters)) will be exceeded.

For each of the available types of information elements (see
[Information Elements](#vardis-definitions-information-elements)) at
most once instance is inserted into a payload. Insertion is considered
in the following order and under the following conditions:

- First step: When `createQ.qIsEmpty()` indicates a non-empty queue,
  then generate an `IETYPE-CREATE-VARIABLES` information element with
  as many `VarCreateT` records as are needed and may fit into the
  VarDis payload.
- Second step: When `deleteQ.qIsEmpty()` indicates a non-empty queue
  and there is sufficient space left in the VarDis payload, then
  generate an `IETYPE-DELETE-VARIABLES` information element with as
  many `VarIdT` values as are needed and may fit into the remaining
  VarDis payload.
- Third step: When `summaryQ.qIsEmpty()` indicates a non-empty queue
  and there is sufficient space left in the VarDis payload, then
  generate an `IETYPE-SUMMARIES` information element with as many
  `VarSummT` records as are needed and may fit into the remaining
  VarDis payload, but not exceeding the value of the
  `VARDISPAR_MAX_SUMMARIES` parameter (assuming this parameter is
  larger than zero).
- Fourth step: When `updateQ.qIsEmpty()` indicates a non-empty queue
  and there is sufficient space left in the VarDis payload, then
  generate an `IETYPE-UPDATES` information element with as many
  `VarUpdT` records as are needed and may fit into the remaining VarDis
  payload.
- Fifth step: When `reqCreateQ.qIsEmpty()` indicates a non-empty queue
  and there is sufficient space left in the VarDis payload, then
  generate an `IETYPE-REQUEST-VARCREATES` information element with as
  many `VarIdT` values as are needed and may fit into the remaining
  VarDis payload.
- Sixth step: When `reqUpdQ.qIsEmpty()` indicates a non-empty queue
  and there is sufficient space left in the VarDis payload, then
  generate an `IETYPE-REQUEST-VARUPDATES` information element with as
  many (`VarIdT`, `VarSeqnoT`) pairs as are needed and may fit into
  the remaining VarDis payload.

When none of these steps produces an information element, then VarDis
will not generate a BP payload.

As described in Section [Information
Elements](#vardis-definitions-information-elements), each such
information element starts with an `IEHeaderT`, followed by a list of
one or more records specific to the type of information element (the
`IEList`). We next describe the process of composing each of these
types of information elements. We make use of a pre-defined function
`numberFittingRecords` which takes as parameters one of the
pre-defined VarDis runtime queues (see Section
[Queues](#vardis-definitions-queues)) and an indication of the type of
records, and calculates how many records of the corresponding record
type can still fit into the remaining BP payload (also accounting for
the size of the `IEHeaderT` and for the maximum number of records that
can fit into the information element, which is equal to the maximum
value representable in the `ieNumRecords` field of `IEHeaderT`). In
this calculation, when `Q` is the queue under consideration (which has
entries of type `VarIdT`), each entry of `Q` is considered at most
once (entries are considered in first-in-first-out order)), and the
function `numberFittingRecords` knows how to calculate the size of a
record for a given `VarIdT` (this size is calculated based on the
current contents of the RTDB for the given `VarIdT`).


### Composing the `IETYPE-SUMMARIES` Element {#vardis-composing-ietype-summaries}

The process of composing the `IETYPE-SUMMARIES` information element
includes the following steps:

~~~
1.     summaryQ.qDropNonexistingDeleted()
2.     If (    (summaryQ.qIsEmpty()) 
            || (no space to add IEHeaderT and one VarSummT)
			|| (VARDISPAR_MAX_SUMMARIES == 0)) then
           stop processing, return empty IETYPE-SUMMARIES element
3.     Let numRecordsToAdd = min(numberFittingRecords(summaryQ,VarSummT), VARDISPAR_MAX_SUMMARIES)
           ieHdr : IEHeaderT
4.     ieHdr.ieType        = IETYPE-SUMMARIES
       ieHdr.ieNumRecords  = numRecordsToAdd
5.     Add ieHdr to IETYPE-SUMMARIES element
6.     for (i=0 ; i<numRecordsToAdd ; i++)
           Let nextVarId = summaryQ.qPeek()
		   summaryQ.qTake()
		   summaryQ.qAppend(nextVarId)
		   Add VarSummT for nextVarId to IETYPE-SUMMARIES element
7.     return the IETYPE-SUMMARIES element
~~~


The preceding procedure adds an `IEHeaderT` and `VarSummT` records to
the `IETYPE-SUMMARIES` element as long as:
 - the number of added records does not exceed
   `VARDISPAR_MAX_SUMMARIES`,
 - the records fit into the remaining BP payload, and
 - no record is added twice.
 
A record to be added is taken from the head of `summaryQ` and then
appended to it. At the start, we remove those `VarIdT` values from
`summaryQ` for which either the underlying variable does not exist in
the real-time database or has been marked for deletion.


### Composing the `IETYPE-CREATE-VARIABLES` Element

The process of composing the `IETYPE-CREATE-VARIABLES` information
element includes the following steps:

~~~
1.     createQ.qDropNonexistingDeleted()
2.     If (    (createQ.qIsEmpty())
            || (no space to add IEHeaderT and first (head-of-createQ) VarCreate)) then
           stop processing, return empty IETYPE-CREATE-VARIABLES element
3.     Let numRecordsToAdd = numberFittingRecords(createQ, VarCreate)
           ieHdr : IEHeaderT
4.     ieHdr.ieType        = IETYPE-CREATE-VARIABLES
       ieHdr.ieNumRecords  = numRecordsToAdd
5.     Add ieHdr to IETYPE-CREATE-VARIABLES element
6.     for (i=0 ; i<numRecordsToAdd ; i++)
           Let nextVarId = createQ.qPeek()
		       nextVar   = RTDB.lookup(nextVarId)
   		   assert(nextVar.countCreate > 0)
		   createQ.qTake()
		   decrement nextVar.countCreate
		   Add VarCreateT (off nextVar entry) to IETYPE-CREATE-VARIABLES
           if (nextVar.countCreate > 0)
		      createQ.qAppend(nextVarId)
7.     Return the constructed IETYPE-CREATE-VARIABLES element
~~~


The preceding procedure adds an `IEHeaderT` and `VarCreateT` records to the
`IETYPE-CREATE-VARIABLES` information elements as long as:
 - the records fit into the BP payload, and
 - no record is added twice.

The repetition counter for each variable is decremented, and the
`VarIdT` is appended to `createQ` again if the repetition counter is
still larger than zero.


### Composing the `IETYPE-UPDATES` Element

This follows almost exactly the same process as for the
`IETYPE-CREATE-VARIABLES` element, with the following substitutions:

- Replace `createQ` by `updateQ`
- Replace `IETYPE-CREATE-VARIABLES` by `IETYPE-UPDATES`
- Replace `countCreate` by `countUpdate`
- Replace `VarCreateT` by `VarUpdT`


### Composing the `IETYPE-DELETE-VARIABLES` Element

The process of composing the `IETYPE-DELETE-VARIABLES` information
element includes the following steps:

~~~
1.     deleteQ.qDropNonexisting()
2.     If (    (deleteQ.qIsEmpty())
            || (no space to add IEHeaderT and VarIdT for head-of-deleteQ)) then
           stop processing, return empty IETYPE-DELETE-VARIABLES element
3.     Let numRecordsToAdd = numberFittingRecords(deleteQ, VarIdT)
           ieHdr : IEHeaderT
4.     ieHdr.ieType        = IETYPE-DELETE-VARIABLES
       ieHdr.ieNumRecords  = numRecordsToAdd
5.     Add ieHdr to IETYPE-DELETE-VARIABLES element
6.     for (i=0 ; i<numRecordsToAdd ; i++)
           Let nextVarId = deleteQ.qPeek()
		       nextVar   = RTDB.lookup(nextVarId)
   		   assert(nextVar.countDelete > 0)
		   deleteQ.qTake()
		   decrement nextVar.countDelete
		   Add nextVarId to IETYPE-DELETE-VARIABLES
           if (nextVar.countDelete > 0)
		      deleteQ.qAppend(nextVarId)
		   else
		      RTDB.remove(nextVarId)
7.     Return the constructed IETYPE-DELETE-VARIABLES element
~~~

The preceding procedure adds an `IEHeaderT` and `VarIdT` records to the
`IETYPE-DELETE-VARIABLES` information elements as long as:
 - the records fit into the BP payload, and
 - no record is added twice.

The repetition counter for each variable is decremented, and the
`VarIdT` is appended to `deleteQ` again if the repetition counter is
still larger than zero. Once the repetition counter has reached zero,
the variable is also deleted from the local RTDB.



### Composing the `IETYPE-REQUEST-VARUPDATES` Element

The process of composing the `IETYPE-REQUEST-VARUPDATES` information
element includes the following steps:

~~~
1.     reqUpdQQ.qDropNonexistingDeleted()
2.     If (    (reqUpdQ.qIsEmpty())
            || (no space to add IEHeaderT and first (head-of-reqUpdQ) VarSummT)) then
           stop processing, return empty IETYPE-REQUEST-VARUPDATES element
3.     Let numRecordsToAdd = numberFittingRecords(reqUpdQ, VarSummT)
           ieHdr : IEHeaderT
4.     ieHdr.ieType        = IETYPE-REQUEST-VARUPDATES
       ieHdr.ieNumRecords  = numRecordsToAdd
5.     Add ieHdr to IETYPE-REQUEST-VARUPDATES element
6.     for (i=0 ; i<numRecordsToAdd ; i++)
           Let nextVarId = reqUpdQ.qPeek()
		       nextVar   = RTDB.lookup(nextVarId)
		   reqUpdQ.qTake()
		   Add VarSummT (off nextVar entry) to IETYPE-REQUEST-VARUPDATES
7.     Return the constructed IETYPE-REQUEST-VARUPDATES element
~~~

The preceding procedure adds an `IEHeaderT` and `VarIdT` records to the
`IETYPE-REQUEST-VARUPDATES` information elements as long as:
 - the records fit into the BP payload, and
 - no record is added twice.

Note that a request for a VarUpdT is only transmitted once.


### Composing the `IETYPE-REQUEST-VARCREATES` Element

This follows exactly the same process as for the
`IETYPE-REQUEST-VARUPDATES` element, with the following substitutions:

  - Replace `reqUpdQ` by `reqCreateQ`
  - Replace `IETYPE-REQUEST-VARUPDATES` by `IETYPE-REQUEST-VARCREATES`
  - Replace `VarSummT` by `VarIdT`
  - Replace `qDropNonexistingDeleted` by `qDropDeleted`


## Initialization, Runtime and Shutdown {#vardis-init-runtime-shutdown}

VarDis will have to perform certain actions at runtime besides
processing received packets, preparing beacon payloads or responding
to service requests from applications. 


### Initialization {#vardis-init-runtime-shutdown-init}

During initialization, VarDis will need to register itself as a client
protocol with the underlying BP. To achieve this registration, VarDis
prepares a `BP-RegisterProtocol.request` service primitive (see
[Service
BP-RegisterProtocol](#bp-interface-service-bp-register-protocol)) with
the following parameters:

- `protId` is set to `BP_PROTID_VARDIS`.
- `name` is set to "VarDis -- Variable Dissemination Protocol Vx.y"
  where 'x' and 'y' refer to the present version of VarDis.
- `maxPayloadSize` is set to the value of the
  `VARDISPAR_MAX_PAYLOAD_SIZE` configuration parameter.
- `queueingMode` is set to `BP_QMODE_QUEUE`.

Furthermore, VarDis performs the following additional actions during
initialization:

- The real-time database `RTDB` is initialized to be empty, i.e. not
  holding any variables.
- All queues (`createQ`, `deleteQ`, `updateQ`, `summaryQ`, `reqUpdQ`,
  `reqCreateQ`) are initialized to be empty.


### Runtime {#vardis-runtime}

The default process by which VarDis generates payloads to transmit is
of a reactive nature: VarDis waits until the underlying BP has
indicated that a payload has just been included in a beacon (see
Section [Service
BP-PayloadTransmitted](#bp-service-payload-transmitted)), upon which
VarDis receives the `BP-PayloadTransmitted.indication` primitive. Note
that in this primitive the underlying BP indicates the point in time
it generates its next beacon, so that the VarDis implementation can
generate and hand over its own payload ahead of time. In response to
this primitive, VarDis then generates the next payload by following
the process described in Section [Payload
Construction](#vardis-payload-format-construction), and submitting the
resulting payload (if any) to the BP by invoking the
`BP-TransmitPayload.request` primitive as follows:

- The `protId` parameter is set to `BP_PROTID_VARDIS`.
- The `length` parameter is set to the length of the new payload in bytes.
- The `value` parameter is set to be the new payload.

However, an additional process is needed in case a
`BP-PayloadTransmitted.indication` is being lost or in order to
initiate the transmission of the very first payload. To achieve this,
VarDis checks periodically (with the period given by the
`VARDISPAR_BUFFER_CHECK_PERIOD` parameter, see Section [Configurable
Parameters](#vardis-configurable-parameters)) the number of payloads
that the BP currently holds for VarDis. It does so by invoking the
`BP-QueryNumberBufferedPayloads.request` service primitive with the
`protId` parameter set to `BP_PROTID_VARDIS`. If the value received in
the `BP-QueryNumberBufferedPayloads.confirm` primitive is valid and
equal to zero, then VarDis generates a beacon payload and, if there is
any, hands it over to the BP by submitting a
`BP-TransmitPayload.request` primitive as above.



### Shutdown

When the operation of VarDis is ending, VarDis performs at least the
following actions:

- It de-registers itself as a client protocol with BP, by preparing a
  `BP-DeregisterProtocol.request` primitive with the `protId`
  parameter set to `BP_PROTID_VARDIS`.
- The real-time database `RTDB` is completely cleared.
- All queues (`createQ`, `deleteQ`, `updateQ`, `summaryQ`, `reqUpdQ`,
  `reqCreateQ`) are set back to be empty.



## Transmit Path

The process ensuring that payloads are being generated at appropriate
times is described in Section [Runtime](#vardis-runtime). 


## Receive Path

We discuss how a node (the "current node") processes the VarDis
payload of a beacon received from a neighbour (the "neighbour node")
and handed to VarDis by the BP.


### Processing Order of Information Elements {#vardis-receive-path-ie-processing-order}

The received VarDis payload contains a number of information elements
of the various types introduced before (Section [Information
Elements](#vardis-definitions-information-elements)). As a very first
step, the current node sequentially extracts all information elements
from the payload, and checks for each information element whether its
type is one of the types of information elements supported by the
implementation. If not, the unknown information element and the
remaining VarDis payload are silently discarded. The received payload
can contain the information elements in any order, and can also
contain two or more elements of the same type.

The valid information elements contained in the payload must be
processed in the following order:

- First step: process all `IETYPE-CREATE-VARIABLES` elements.
- Second step: process all `IETYPE-DELETE-VARIABLES` elements.
- Third step: process all `IETYPE-UPDATES` elements.
- Fourth step: process all `IETYPE-SUMMARIES`, `IETYPE-REQUEST-VARCREATES`
  and `IETYPE-REQUEST-VARUPDATES` elements in any convenient order.

The rationale for processing `IETYPE-CREATE-VARIABLES` and
`IETYPE-DELETE-VARIABLES` elements before `IETYPE-UPDATES` is that a
producer node might in the same payload not only include the
information element for creating the variable, but also an update for
that same variable. However, as updates are only allowed to be carried
out for existing variables, the 'Create' instruction should be
processed first, otherwise the update will be rejected. For a similar
reason `IETYPE-UPDATES` elements should be processed after
`IETYPE-DELETE-VARIABLE` elements, as updates are not carried out
while a variable is in the process of deletion.

Furthermore, it is also helpful to process `IETYPE-UPDATES` before
`IETYPE-SUMMARIES`. To see why, imagine that a neighbour includes both
a summary and an update for the same variable in the same payload,
showing the same sequence number. Assume that the receiver only
possesses an older sequence number at the time of reception. If the
receiver were to process the summary first, it would notice that it
only has that variable in an outdated version and might itself
instigate transmission of a `IETYPE-REQUEST-VARUPDATES` element for
that variable. But that would be un-necessary.

The receive path extracts the information elements (header and list of
records) out of the received payload in a sequential manner. When
processing an individual record certain error conditions may arise
that prohibit further processing, e.g. a record will have a larger
length than there are bytes available in the as-yet-unprocessed part
of the payload. In these cases the remaining payload shall remain
un-processed, but the effects of the already correctly processed
information elements and records shall remain valid.


### Processing `IETYPE-CREATE-VARIABLES` Elements {#vardis-receive-path-ie-create-variables}

The contents of an `IETYPE-CREATE-VARIABLES` information element is a
list of `VarCreateT` records. For a specific such record `rcvdVC` of
type `VarCreateT` the receiving VarDis instance performs the following
steps:

~~~
1.     Let spec : VarSpecT    = rcvdVC.spec
           upd : VarUpdT      = rcvdVC.upd
		   varId : VarIdT     = spec.varId
2.     If (RTDB.lookup (varId) == true) then
          stop processing
3.     If (spec.prodId == own node id) then
          stop processing
4.     If (    (upd.length > VARDISPAR_MAX_VALUE_LENGTH) 
            || (spec.descr.length > VARDISPAR_MAX_DESCRIPTION_LENGTH-1))
	      stop processing
5.     Let newent : DBEntry with
           newent.spec         =  spec
		   newent.length       =  upd.length
		   newent.value        =  upd.value
		   newent.seqno        =  upd.seqno
		   newent.tStamp       =  current system time
		   newent.countUpdate  =  0
		   newent.countCreate  =  spec.repCnt
		   newent.countDelete  =  0
		   newent.toBeDeleted  =  False

6.     createQ.qRemove (spec.varId)
7.     deleteQ.qRemove (spec.varId)
8.     updateQ.qRemove (spec.varId)
9.	   summaryQ.qRemove (spec.varId)
10.	   reqUpdQ.qRemove (spec.varId)
11.	   reqCreateQ.qRemove (spec.varId)


12.    RTDB.update(newent)
13.    createQ.qAppend(varId)
14.    summaryQ.qAppend(varId)
15.    reqCreateQ.qRemove(varId)
~~~



### Processing `IETYPE-DELETE-VARIABLES` Elements

The contents of an `IETYPE-DELETE-VARIABLES` information element is a
list of `VarIdT` values. For each included `VarIdT` value `varId`
the receiving VarDis instance performs the following steps:

~~~
1.     If (RTDB.lookup(varId) == false) then
           stop processing
2.     Let ent = RTDB.lookup(varId)
3.     If (ent.toBeDeleted == True) then
           stop processing
4.     If (ent.spec.prodId == own node id) then
           stop processing
5.     ent.toBeDeleted = True
6.     ent.countUpdate = 0
7.     ent.countCreate = 0
8.     ent.countDelete = ent.spec.repCnt
9.     RTDB.update(ent)
10.    updateQ.qRemove(varId)
11.    createQ.qRemove(varId)
12.    reqUpdQ.qRemove(varId)
13.    reqCreateQ.qRemove(varId)
14.    summaryQ.qRemove(varId)
15.    deleteQ.qRemove(varId)
16.    deleteQ.qAppend(varId)
~~~





### Processing `IETYPE-UPDATES` Elements {#vardis-receive-path-ie-updates}

The contents of an `IETYPE-UPDATES` information element is a list of
`VarUpdT` records. For each included `VarUpdT` record `upd` the
receiving VarDis instance performs the following steps:

~~~
1.     If (RTDB.lookup(upd.varId) == false) then
           If (reqCreateQ.qExists(upd.varId) == false) then
               reqCreateQ.qAppend(upd.varId)
		   stop processing
2.     Let ent = RTDB.lookup(upd.varId)
3.     If (ent.toBeDeleted == True) then
           stop processing
4.     If (ent.spec.prodId == own node id) then
           stop processing
5.     If (upd.length > VARDISPAR_MAX_VALUE_LENGTH)
	       stop processing
6.     If (upd.seqno == ent.seqno) then
           stop processing
7.     If (upd.seqno is strictly older than ent.seqno) then
           if (updateQ.qExists(upd.varId) == false) then
		       updateQ.qAppend(upd.varId)
			   ent.countUpdate = ent.spec.repCnt
			   RTDB.update(ent)
	       stop processing
8.     ent.length        =  upd.length
9.     ent.value         =  upd.value
10.     ent.seqno         =  upd.seqno
11.    ent.tStamp        =  current system time
12.    ent.countUpdate   =  ent.spec.repCnt
13.    RTDB.update(ent)
14.    if (updateQ.qExists(upd.varId) == false) then
           updateQ.qAppend(upd.varId)
15.    reqUpdQ.qRemove(upd.varId)
~~~



### Processing `IETYPE-SUMMARIES` Elements

The contents of an `IETYPE-SUMMARIES` information element is a list of
`VarSummT` records. For each included `VarSummT` record `summ` the
receiving VarDis instance performs the following steps:

~~~
1.     If (RTDB.lookup(summ.varId) == false) then
           If (reqCreateQ.qExists(summ.varId) == false) then
               reqCreateQ.qAppend(summ.varId)
		   stop processing
2.     Let ent = RTDB.lookup(summ.varId)
3.     If (ent.toBeDeleted == true) then
           stop processing
4.     If (ent.spec.prodId == own node id) then
           stop processing
5.     If (summ.seqno == ent.seqno) then
           stop processing
6.     If (summ.seqno is strictly older than ent.seqno) then
           if (updateQ.qExists(summ.varId) == false) then
		       updateQ.qAppend(summ.varId)
			   ent.countUpdate = ent.spec.repCnt
			   RTDB.update(ent)
	       stop processing
7.     if (reqUpdQ.qExists(summ.varId) == false) then
           reqUpdQ.qAppend(summ.varId)
~~~




### Processing `IETYPE-REQUEST-VARUPDATES` Elements

The contents of an `IETYPE-REQUEST-VARUPDATES` information element is
a list of (`VarIdT`, `VarSeqnoT`) pairs. For each such pair (`varId`,
`seqno`) the receiving VarDis instance performs the following steps:

~~~
1.     If (RTDB.lookup(varId) == false) then
           If (reqCreateQ.qExists(summ.varId) == false) then
               reqCreateQ.qAppend(summ.varId)
           stop processing
2.     Let ent = RTDB.lookup(varId)
3.     If (ent.toBeDeleted == True) then
           stop processing
4.     If (ent.seqno is not strictly larger than seqno) then
           stop processing
5.     ent.countUpdate  =  ent.spec.repCnt
6.     RTDB.update(ent)
7.     if (updateQ.qExists(varId) == false) then
           updateQ.qAppend(varId)
~~~




### Processing `IETYPE-REQUEST-VARCREATES` Elements

The contents of an `IETYPE-REQUEST-VARCREATES` information element is
a list of `VarIdT` values. For each such value `varId` the receiving
VarDis instance performs the following steps:

~~~
1.     If (RTDB.lookup(varId) == false) then
           If (reqCreateQ.qExists(summ.varId) == false) then
               reqCreateQ.qAppend(summ.varId)
           stop processing
2.     Let ent = RTDB.lookup(varId)
3.     If (ent.toBeDeleted == true) then
           stop processing
4.     ent.countCreate  =  ent.spec.repCnt
5.     RTDB.update(ent)
6.     If (createQ.qExists(varId) == false) then
           createQ.qAppend(varId)
~~~


## Implementation requirements

An implementation may choose to allocate various VarDis activities to
a number of parallel processes or threads, for example one thread for
handling service requests from a VarDis application, one thread for
processing received payloads and one thread for generating and sending
payloads. Should these threads have any shared data structures (like
for example the real-time database itself or the various queues), then
the implementation must ensure proper mutual exclusion when accessing
these shared data structures.


## Known specification gaps


### Handling of sequence numbers in case of producer crashes

When a node has produced a variable with a certain identifier, has run
long enough to count up the sequence number to some large nonzero
value, and then crashes, restarts fast and initializes the sequence
number of this variable to zero again, then a number of future
variable updates will be rejected by other nodes as being outdated
(they will still have the variable in their local database). A
mechanism is needed to make sure that consumer nodes will re-set their
local sequence numbers and accept the new `VarCreateT` instruction and
any future `VarUpdateT` instructions.

