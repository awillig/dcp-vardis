---

# The State-Reporting Protocol (SRP) {#chap-state-reporting-protocol}

This section describes the DCP state-reporting protocol (SRP).


## Purpose

The state-reporting protocol (SRP) provides frequent transmission of
safety-related information about a drone (such as its position, speed,
heading and any other safety-related data) to neighboured drones,
inside of beacons. In the other direction, it receives those safety
transmissions from neighboured drones and consolidates them into a
**neighbour table**, which can be used by applications to check, for
example, the risk of an imminent collision. The size of the
neighbourhood is determined by external factors such as the chosen
transmit power or properties of the propagation environment, and is
not under the control of this protocol. The neighbour table entries
are equipped with a soft-state mechanism. The safety-related
information has strictly single-hop scope.

The SRP operates on top of the beaconing protocol (see Section
[Beaconing Protocol](#chap-beaconing-protocol)) as a client
protocol. 


## Key Data Types and Definitions

### Data Types

- The transmissible data type `SRPSequenceNumber` is a 32-bit unsigned
  integer. Sequence numbers are included in SRP payloads.

- The transmissible data type `SafetyData` refers to all the data that
  a drone wants to transmit to its neighbours, for example its current
  position, speed and direction, or some information about its
  short-term trajectory. The precise details of this data type are
  implemention-dependent and therefore the generation of values is
  left to applications, but `SafetyData` records have a fixed size
  (given by `sizeof(SafetyData)`.

- The transmissible data type `ExtendedSafetyData` acts as a wrapper
  around the type `SafetyData`. It contains additional fields, and the
  SRP is actually concerned with the transmission of values of type
  `ExtendedSafetyData` and their wholesale storage in the neighbour
  table.  An `ExtendedSafetyData` record contains the following fields:
    - `sData` of type `SafetyData` is the actual safety data record
      wrapped into the present `ExtendedSafetyData` record.
    - `nodeId` of type `NodeIdentifier` contains the node identifier
      of the node that generated the `ExtendedSafetyData` record. 
    - `tStamp` of type `TimeStamp` (see Section [Data
      Types](#chap-datatypes)) is generated by the SRP when a
      `SafetyData` record is handed down by applications for
      transmission 
    - `seqno` of type `SRPSequenceNumber` is a sequence number
      associated with the present `ExtendedSafetyData` record. Two
      successive `ExtendedSafetyData` records generated in response to
      two `SafetyData` records received from the application must have
      distinct sequence numbers.
  
- The non-transmissible data type `NeighbourTableEntry` record has the
  following fields:
    - `nodeId` of type `NodeIdentifier`
    - `extSD` of type `ExtendedSafetyData` is the last value of type
      `ExtendedSafetyData` received from the drone with identifier
      `nodeId`.
	- `receptionTime` of type `Timestamp` contains the local timestamp
	  of the time the last value in `extSD` has been received, as
	  generated by   the SRP entity upon successfully processing a
	  received `BP-ReceivePayload.indication` primitive. Assuming
	  sufficiently well synchronized local clocks among neighboured
	  nodes, the difference between this timestamp and the timestamp
	  contained in `extSD.tStamp` gives an indication of the delay
	  introduced by the underlying BP and UWB.

### The Neighbour Table

The non-transmissible `NeighbourTable` data type is a collection of a
number of `NeighbourTableEntry` records, together with some
pre-defined operations on this collection. These include:

- `ntLookup(nodeId)`: the parameter `nodeId` is of type
  `NodeIdentifier` and refers to the identifier of the node for which 
  a full `NeighbourTableEntry` is to be found in the table. This
  operation can end unsuccessful if the table does not contain
  an entry for which its `nodeId` field equals the parameter, in which
  case a `NULL` value is returned. Alternatively, if such an entry
  exists, it returns this (unique) entry.
- `ntListAllNodeIds()`: returns a list of all `nodeId` fields for all
  `NeighbourTableEntry` records currently in the neighbour table, in
  no guaranteed order.

There is a single variable `neighbourTable` of type
`NeighbourTable`. The neighbour table only contains records for
neighboured nodes, not for the hosting node itself.

An implementation might provide additional, more specific functions
for querying the contents of the `NeighbourTable`, e.g. listing
entries in order of increasing distance. Applications can use these
functions for example to assess the risk of a collision in a given
time window, or to assess the amount of uncertainty in the position
data of a neighbour from the available timestamps.

### The Sequence Number

The SRP entity maintains a global variable called
`currentSequenceNumber` of type `SRPSequenceNumber`.


## Interface

SRP offers its services to the applications through the service
interface described in the following.

Whenever an application submits a service request primitive, SRP must
check whether it is currently registered as a client protocol with
BP. If not, then SRP must reject the service request primitive,
i.e. send back a response primitive with status code
`SRP-STATUS-INACTIVE' to the application.

### Service SRP-TransmitSafetyData

The purpose of this service is to allow an application to submit a new
`SafetyData` record for transmission.

The service user invokes this service by using the
`SRP-TransmitSafetyData.request` primitive, which carries the following
parameters:
- `sData` of type `SafetyData`

After receiving the `SRP-TransmitSafetyData.request` primitive the SRP
performs at least the following actions:

~~~
1.     Let extsd : ExtendedSafetyData with
           extsd.sData   =  sData
		        .nodeId  =  own node identifier
				.tStamp  =  current system time
				.seqno   =  currentSequenceNumber
2.     increment currentSequenceNumber modulo (MAXVAL(SRPSequenceNumber)+1)
3.     Prepare BP-TransmitPayload.request primitive req with
          req.protId  = BP_PROTID_SRP
		     .length  = sizeof(ExtendedSafetyData)
			 .payload = extsd
4.     Submit req to BP.
5.     stop processing, return SRP-STATUS-OK
~~~



### Neighbour Table Access

The way applications access the neighbour table is considered as
implementation-dependent and not specified in this document.


### Configurable Parameters {#srp-configurable-parameters}

- `SRPPAR_NEIGHBOUR_TABLE_TIMEOUT` in milliseconds: if a node doesn't
  receive a new `ExtendedSafetyData` from a particular neighbour for
  this many milliseconds, then the neighbour table entry will be
  dropped. Default value: 3,000 (corresponding to 3 seconds).


## Packet Format

The payload transmitted and received by SRP are all of type
`ExtendedSafetyData`.


## Initialization, Runtime and Shutdown

The SRP will have to perform certain actions besides processing
packets or responding to service requests from the application.


### Initialization

During the initialization, the SRP will need to register itself as a
client protocol with the underlying BP before it can process any
`SRP-TransmitSafetyData.request` primitives. To achieve this
registration, the SRP prepares a `BP-RegisterProtocol.request` service
primitive (see [Service
BP-RegisterProtocol](#bp-interface-service-bp-register-protocol)) with
the following parameters:

- `protId` is set to `BP_PROTID_SRP`
- `name` is set to "SRP -- State Reporting Protocol Vx.y" where
  'x' and 'y' refer to the present version of SRP.
- `maxPayloadSize` is set to
  `sizeof(ExtendedSafetyData)`. Implementations may opt to add an
  additional safety margin.
- `queueingMode` is set to `BP_QUEUEING_MODE_REPEAT`, meaning that the
  BP will always transmit the last `ExtendedSafetyData` record that the
  SRP has handed over.

The variable `neighbourTable` of type `NeighbourTable` is  initialized
as being empty.

The variable `currentSequenceNumber` of type `SRPSequenceNumber` is
initialized to zero.


### Runtime

The SRP entity traverses the neighbour table `neighbourTable` at a
frequency chosen such that during any time interval of length
`SRPPAR_NEIGHBOUR_TABLE_TIMEOUT` (see [Configurable
Parameters](#srp-configurable-parameters)) at least five traversals
are carried out. During each traversal the SRP entity first obtains
the current system time and then checks for each entry `ent` of type
`ExtendedSafetyData` contained in `neighbourTable` whether the
difference between the current system time and the
(receiver-generated) timestamp `ent.receptionTime` exceeds the value
of the `SRPPAR_NEIGHBOUR_TABLE_TIMEOUT` parameter. If so, the
neighbour table entry is dropped from the table.


### Shutdown

During the shutdown, the SRP will de-register itself from the
BP, by issueing the service primitive `BP-DeregisterProtocol.request`
with the `protId` parameter set to `BP_PROTID_SRP`.



## Receive Path

The receive path is activated when the underlying BP signals the
reception of an SRP payload with the `BP-ReceivePayload.indication`
primitive (see [Service
BP-ReceivePayload](#bp-service-bp-receive-payload)). In this case,
referring to the received primitive as `payloadIndication`, the SRP
performs at least the following actions:

~~~
1.     If (    (payloadIndication.protId =/= BP_PROTID_SRP)
            || (payloadIndication.length =/= sizeof(ExtendedSafetyData)) then
          stop processing.
2.     Let ext : ExtendedSafetyData = payloadIndication.payload
3.     If (ext.nodeId == own node identifier) then
          stop processing.
4.     Let ent : NeighbourTableEntry with
	       ent.nodeId         =  ext.nodeId
			  .extSD          =  ext
			  .receptionTime  =  current system time
          add ent to neighbourTable or replace existing entry for ext.nodeId
		  stop processing.
~~~

Implementations may choose to extend the data type
`NeighbourTableEntry` by further fields and add appropriate processing
here. For example, the sequence numbers contained in values of type
`ExtendedSafetyData` can be used to estimate packet loss rate between
the neighbour and the the current node.
